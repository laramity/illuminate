<?php
/**
 * @link https://github.com/yii2tech
 * @copyright Copyright (c) 2019 Yii2tech
 * @license [New BSD License](http://www.opensource.org/licenses/bsd-license.php)
 */

namespace Yii2tech\Illuminate\Yii\Web;

use Illuminate\Http\JsonResponse as IlluminateJsonResponse;
use Illuminate\Http\Response as IlluminateResponse;
use Symfony\Component\HttpFoundation\Cookie;
use Yii;
use yii\base\InvalidConfigException;
use yii\web\HeadersAlreadySentException;
use Yii2tech\Illuminate\Http\EmptyResponse;
use Yii2tech\Illuminate\Http\FileResponse;
use Yii2tech\Illuminate\Http\StreamResponse;

/**
 * Response fills up Laravel HTTP response instead of sending itself back to the user agent.
 *
 * This class allows Laravel middleware to perform post processing for the responses generated by Yii.
 *
 * Application configuration example:
 *
 * ```php
 * return [
 *     'components' => [
 *         'response' => Yii2tech\Illuminate\Yii\Web\Response::class,
 *         // ...
 *     ],
 *     // ...
 * ];
 * ```
 *
 * Usage of this component also allows returning of the response generated by Laravel from Yii controller. For example:
 *
 * ```php
 * class FooController extends \yii\web\Controller
 * {
 *     public function actionFoo()
 *     {
 *         // ...
 *         return Yii::$app->response->setIlluminateResponse(redirect('foo/create')->withInput());
 *     }
 * }
 * ```
 *
 * @see \Illuminate\Http\Response
 * @see \Yii2tech\Illuminate\Http\YiiApplicationMiddleware
 *
 * @property \Illuminate\Http\Response $illuminateResponse related Laravel response.
 *
 * @author Paul Klimov <klimov.paul@gmail.com>
 * @since 1.0
 */
class Response extends \yii\web\Response
{
    /**
     * @var \Illuminate\Http\Response|\Illuminate\Http\JsonResponse|EmptyResponse|FileResponse|StreamResponse|null related Laravel response.
     */
    private $_illuminateResponse;

    /**
     * @param  bool  $create whether to create a response, if it is empty.
     * @return \Illuminate\Http\Response|\Illuminate\Http\JsonResponse|EmptyResponse|FileResponse|StreamResponse|null
     */
    public function getIlluminateResponse(bool $create = false)
    {
        if ($create && $this->_illuminateResponse === null) {
            $this->_illuminateResponse = $this->createIlluminateResponse();
        }

        return $this->_illuminateResponse;
    }

    /**
     * @param  \Illuminate\Http\Response|\Illuminate\Http\JsonResponse|EmptyResponse|FileResponse|StreamResponse|null  $illuminateResponse
     * @return static reference.
     */
    public function setIlluminateResponse($illuminateResponse = null): self
    {
        $this->_illuminateResponse = $illuminateResponse;

        return $this;
    }

    /**
     * Creates default {@see $illuminateResponse} instance.
     *
     * @return \Illuminate\Http\Response Laravel response instance.
     */
    protected function createIlluminateResponse(): IlluminateResponse
    {
        return \Illuminate\Container\Container::getInstance()->make(IlluminateResponse::class);
    }

    /**
     * Creates default {@see $illuminateResponse} instance.
     *
     * @return \Illuminate\Http\JsonResponse Laravel response instance.
     */
    protected function createIlluminateJsonResponse(): IlluminateJsonResponse
    {
        return \Illuminate\Container\Container::getInstance()->make(IlluminateJsonResponse::class);
    }

    /**
     * Creates default {@see $illuminateResponse} instance.
     *
     * @return FileResponse Binary file response instance.
     */
    protected function createIlluminateFileResponse(): FileResponse
    {
        $filePath = sys_get_temp_dir() . DIRECTORY_SEPARATOR . uniqid('ybf');
        file_put_contents($filePath, $this->content);

        return \Illuminate\Container\Container::getInstance()->make(FileResponse::class, ['file' => $filePath]);
    }

    /**
     * Creates default {@see $illuminateResponse} instance.
     *
     * @return StreamResponse Stream response instance.
     */
    protected function createIlluminateStreamResponse(): StreamResponse
    {
        $streamCallback = function () {
            if (is_callable($this->stream)) {
                $data = call_user_func($this->stream);
                foreach ($data as $datum) {
                    echo $datum;
                    flush();
                }
                return;
            }

            $chunkSize = 8 * 1024 * 1024; // 8MB per chunk

            if (is_array($this->stream)) {
                list($handle, $begin, $end) = $this->stream;

                // only seek if stream is seekable
                if ($this->isSeekable($handle)) {
                    fseek($handle, $begin);
                }

                while (!feof($handle) && ($pos = ftell($handle)) <= $end) {
                    if ($pos + $chunkSize > $end) {
                        $chunkSize = $end - $pos + 1;
                    }
                    echo fread($handle, $chunkSize);
                    flush(); // Free up memory. Otherwise large files will trigger PHP's memory limit.
                }
                fclose($handle);
            } else {
                while (!feof($this->stream)) {
                    echo fread($this->stream, $chunkSize);
                    flush();
                }
                fclose($this->stream);
            }
        };

        return \Illuminate\Container\Container::getInstance()->make(StreamResponse::class, ['callback' => $streamCallback]);
    }

    /**
     * Creates default {@see $illuminateResponse} instance.
     *
     * @return EmptyResponse Laravel response instance.
     */
    protected function createIlluminateEmptyResponse(): EmptyResponse
    {
        return \Illuminate\Container\Container::getInstance()->make(EmptyResponse::class);
    }

    /**
     * {@inheritdoc}
     */
    public function clear(): void
    {
        parent::clear();

        $this->setIlluminateResponse(null);
    }

    /**
     * {@inheritdoc}
     */
    public function send(): void
    {
        if ($this->getIlluminateResponse() !== null) {
            $this->isSent = true;

            return;
        }

        parent::send();
    }

    /**
     * {@inheritdoc}
     */
    protected function prepare(): void
    {
//        if ($this->stream === null) {
            // avoid usage of response bridge for file sending, since it may cause PHP memory error.
        $response = $this->getIlluminateResponse();
        if ($response === null) {
            if ($this->format === self::FORMAT_JSON && $this->data !== null) {
                $this->setIlluminateResponse($this->createIlluminateJsonResponse());
            } elseif ($this->format === self::FORMAT_RAW && !empty($this->content)) {
                $this->setIlluminateResponse($this->createIlluminateFileResponse());
            } elseif ($this->format === self::FORMAT_RAW && $this->stream !== null) {
                $this->setIlluminateResponse($this->createIlluminateStreamResponse());
            } elseif ($this->content !== null || $this->data !== null) {
                $this->setIlluminateResponse($this->createIlluminateResponse());
            } else {
                $this->setIlluminateResponse($this->createIlluminateEmptyResponse());
            }
        }
//        }

        parent::prepare();
    }

    /**
     * {@inheritdoc}
     */
    protected function sendHeaders(): void
    {
        $response = $this->getIlluminateResponse();
        if ($response === null) {
            parent::sendHeaders();

            return;
        }

        if (headers_sent($file, $line)) {
            throw new HeadersAlreadySentException($file, $line);
        }

        $response->setProtocolVersion($this->version);
        $response->setStatusCode($this->getStatusCode(), $this->statusText);

        foreach ($this->getHeaders() as $name => $values) {
            $response->headers->set($name, $values);
        }

        $this->sendCookies();
    }

    /**
     * {@inheritdoc}
     */
    protected function sendCookies(): void
    {
        $response = $this->getIlluminateResponse();
        if ($response === null) {
            parent::sendCookies();

            return;
        }

        $request = Yii::$app->getRequest();
        if ($request->enableCookieValidation) {
            if ($request->cookieValidationKey == '') {
                throw new InvalidConfigException(get_class($request) . '::$cookieValidationKey must be configured with a secret key.');
            }
            $validationKey = $request->cookieValidationKey;
        }

        foreach ($this->getCookies() as $cookie) {
            $value = $cookie->value;
            if ($cookie->expire != 1 && isset($validationKey)) {
                $value = Yii::$app->getSecurity()->hashData(serialize([$cookie->name, $value]), $validationKey);
            }

            $response->headers->setCookie(new Cookie($cookie->name, $value, $cookie->expire, $cookie->path, $cookie->domain, $cookie->secure, $cookie->httpOnly));
        }
    }

    /**
     * {@inheritdoc}
     */
    protected function sendContent(): void
    {
        if ($this->format === self::FORMAT_RAW) {
            return;
        }

        $response = $this->getIlluminateResponse();
        if ($response === null) {
            parent::sendContent();

            return;
        }

        if ($this->stream === null) {
            if ($this->format === self::FORMAT_JSON && $this->data !== null) {
                $response->setData($this->data);
            } elseif ($this->content !== null) {
                $response->setContent($this->content);
            }

            return;
        }

        ob_start();
        ob_implicit_flush(false);

        try {
            parent::sendContent();

            $response->setContent(ob_get_clean());
        } catch (\Throwable $e) {
            if (!@ob_end_clean()) {
                ob_clean();
            }
            throw $e;
        }
    }

    /**
     * Checks if a stream is seekable
     *
     * @param $handle
     * @return bool
     */
    protected function isSeekable($handle)
    {
        if (!is_resource($handle)) {
            return true;
        }

        $metaData = stream_get_meta_data($handle);
        return isset($metaData['seekable']) && $metaData['seekable'] === true;
    }
}
